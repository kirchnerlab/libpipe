<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<!--BEGIN PROJECT_NAME--><title>libpipe: libpipe: Usage</title><!--END PROJECT_NAME-->
<!--BEGIN !PROJECT_NAME--><title>libpipe: Usage</title><!--END !PROJECT_NAME-->
<LINK HREF="doxygen.css" REL="stylesheet" TYPE="text/css">
$treeview
$search
$mathjax
</head>
<body>
<div id="top"><!-- do not remove this div! -->

<!--BEGIN TITLEAREA-->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <!--BEGIN PROJECT_LOGO-->
  <td id="projectlogo"><img alt="Logo" src="$projectlogo"/></td>
  <!--END PROJECT_LOGO-->
  <!--BEGIN PROJECT_NAME-->
  <td style="padding-left: 0.5em;">
   <div id="projectname">libpipe
   <!--BEGIN PROJECT_BRIEF--><div id="projectbrief">$projectbrief</div><!--END PROJECT_BRIEF-->
   
   </div>
   <!--BEGIN PROJECT_NUMBER-->&#160;<span id="projectnumber">Git Commit: 7fe1f9eb5d163890492850ec40bf0894c079adeb</span><!--END PROJECT_NUMBER-->
  </td>
  <!--END PROJECT_NAME-->
  <!--BEGIN !PROJECT_NAME-->
   <!--BEGIN PROJECT_BRIEF-->
    <td style="padding-left: 0.5em;">
    <div id="projectbrief">$projectbrief</div>
    </td>
   <!--END PROJECT_BRIEF-->
  <!--END !PROJECT_NAME-->
  <!--BEGIN DISABLE_INDEX-->
   <!--BEGIN SEARCHENGINE-->
   <td>$searchbox</td>
   <!--END SEARCHENGINE-->
  <!--END DISABLE_INDEX-->
 </tr>
 </tbody>
</table>
</div>
<!--END TITLEAREA-->
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Usage </h1>  </div>
</div>
<div class="contents">
<div class="textblock"><h3>Generate new Runtime Configuration Algorithms </h3>
<p>To generate a new Algorithm you need to generate a new class which inherits from <a class="el" href="classlibpipe_1_1rtc_1_1_algorithm.html">libpipe::rtc::Algorithm</a>. This class needs to implement the following functions: </p>
<ul>
<li>
public methods: <ul>
<li>
<div class="fragment"><pre class="fragment"> <span class="keyword">static</span> Algorithm* create() 
</pre></div> </li>
<li>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> update(<a class="code" href="classlibpipe_1_1_request.html">libpipe::Request</a>&amp; req) 
</pre></div> </li>
<li>
<div class="fragment"><pre class="fragment"> The Destructor 
</pre></div> </li>
</ul>
</li>
<li>
protected methods: <ul>
<li>
<div class="fragment"><pre class="fragment"> The Constructor
</pre></div> </li>
</ul>
</li>
<li>
<p class="startli">private methods and variables: </p>
<ul>
<li>
<div class="fragment"><pre class="fragment"> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> registerLoader() 
</pre></div> </li>
<li>
<div class="fragment"><pre class="fragment"> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> registered_;
</pre></div> </li>
</ul>
<p class="endli"></p>
</li>
</ul>
<p>Lets go through the individual functions and what you need to implement:</p>
<h4>create() Method </h4>
<p>This method needs to return a pointer to the base class. Internally the pointer should be a pointer to your algorithm class. So the implementation should look like this: </p>
<div class="fragment"><pre class="fragment">        <span class="keyword">static</span> Algorithm* create()
        {
            <span class="keywordflow">return</span> <span class="keyword">new</span> YOURAlgorithm;
        }
</pre></div><h4>update(libpipe::Request&amp; req) Method </h4>
<p>This method will contain your actual algorithm. In the end the method should return the request. To add Information to the request trace use the following code inside the method: </p>
<div class="fragment"><pre class="fragment"> LIBPIPE_PIPELINE_TRACE(req, <span class="stringliteral">&quot;YOUR MESSAGE&quot;</span>); 
</pre></div><p> To have access to your defined in- and output ports you should add the following macro at the beginning of the method for convenience: </p>
<div class="fragment"><pre class="fragment">LIBPIPE_PREPARE_READ_ACCESS(input1_, tempIn1, Doubles, <span class="stringliteral">&quot;MatrixIn1&quot;</span>);
LIBPIPE_PREPARE_WRITE_ACCESS(output_, tempOut, Doubles, <span class="stringliteral">&quot;MatrixOut&quot;</span>);
</pre></div><p> This macro gives you access to your in and output. If you want to write your data make sure that you call , as this enables thread safe writting under the hood.</p>
<p>The first argument of your macro will generate a variable of this name where your in/output is stored. The second parameter will give you a variable with direct access to the data. The third parameter will be the type of your data. The last argument is the name of the port where your data is stored.</p>
<p>If you want to delete memory if a delete request is called on your algorithm you can do this by checking the type of the request: </p>
<div class="fragment"><pre class="fragment"><span class="keywordflow">if</span> (req.<a class="code" href="classlibpipe_1_1_request.html#a999deaee7bf56cdcdd75fceebd0677eb">is</a>(libpipe::Request::UPDATE) and this-&gt;needUpdate()) {
    <span class="comment">//code if update is called</span>
} <span class="keywordflow">else</span> <span class="keywordflow">if</span> (req.<a class="code" href="classlibpipe_1_1_request.html#a999deaee7bf56cdcdd75fceebd0677eb">is</a>(libpipe::Request::DELETE)) {
    <span class="comment">//code if delete is called</span>
}
</pre></div><p>At the end of you update methode you need to clean up your data objects. This can be done by the macro (input1_) where the first argument is your variable storing the in/output is stored.</p>
<h4>The Destructor </h4>
<p>If you have not allocated memory in your class an empty destructor is sufficient.</p>
<h4>The Constructor </h4>
<p>Make sure to call the <a class="el" href="classlibpipe_1_1rtc_1_1_algorithm.html">libpipe::rtc::Algorithm</a> Constructor. </p>
<div class="fragment"><pre class="fragment"> YOUR_ALGORITHM() :
                libpipe::rtc::Algorithm()
        { ...
</pre></div><p> Inside the constructor register your in- and output ports. </p>
<div class="fragment"><pre class="fragment">ports_[<span class="stringliteral">&quot;YOUR_PORT_IDENTIFIER&quot;</span>] = <a class="codeRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01171.html#ga3e40f2d796edcbadaed5431f8c1fc1a8">boost::make_shared</a>&lt;
                    <a class="code" href="classlibpipe_1_1rtc_1_1_shared_data.html">libpipe::rtc::SharedData&lt;std::string&gt;</a> &gt;();
</pre></div><p> In the example above you will register the port "YOUR_PORT_IDENTIFIER" with the Type libpipe::rtc::SharedData&lt;std::string&gt;. If you want to use your own Type look at section <a href="#datatypes">Datatype</a>. Your Types need to be encapsulated in boost::shared_ptr.</p>
<p>If you define output Ports make sure to initialize these ports. Otherwise you will get segmentation faults. </p>
<div class="fragment"><pre class="fragment">ports_[<span class="stringliteral">&quot;YOUR_OUTPUT_PORT&quot;</span>] = <a class="codeRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01171.html#ga3e40f2d796edcbadaed5431f8c1fc1a8">boost::make_shared</a>&lt;
   <a class="code" href="classlibpipe_1_1rtc_1_1_shared_data.html">libpipe::rtc::SharedData&lt;std::string&gt;</a> &gt;(<span class="keyword">new</span> <a class="codeRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01203.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>);
</pre></div><h4>registerLoader() Method </h4>
<p>This method will register your new algorithm class in the AlgorithmFactory. You can copy paste this method to your algorithm class, only change the identifier to you own individual one and call the create methode of your own class. </p>
<div class="fragment"><pre class="fragment"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> registerLoader()
{
    <a class="codeRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01203.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> ids = <span class="stringliteral">&quot;YOUR_ALGORITM_IDENTIFIER&quot;</span>;
    <span class="keywordflow">return</span> <a class="code" href="classlibpipe_1_1utilities_1_1_singleton.html#ab7455b7e1235d292c444095842349291">libpipe::rtc::AlgorithmFactory::instance</a>().registerType(ids,YOUR_ALGORITHM::create);
}
</pre></div><p> To register your algorithm you need also to add this line of code outside your class: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">const</span> <span class="keywordtype">bool</span> YOUR_ALGORITHM::registered_ = registerLoader();
</pre></div><h3>Generate new Managers </h3>
<p>If you really need to, implement the following functions: </p>
<ul>
<li>
public methods: <ul>
<li>
<div class="fragment"><pre class="fragment"> <span class="keyword">static</span> Manager* create() 
</pre></div> </li>
<li>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> processRequest(Request&amp; req);
</pre></div> </li>
<li>
<div class="fragment"><pre class="fragment"> The Destructor 
</pre></div> </li>
</ul>
</li>
<li>
protected methods: <ul>
<li>
<div class="fragment"><pre class="fragment"> The Constructor
</pre></div> </li>
</ul>
</li>
<li>
private methods and variables: <ul>
<li>
<div class="fragment"><pre class="fragment"> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> registerLoader() 
</pre></div> </li>
<li>
<div class="fragment"><pre class="fragment"> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> registered_;
</pre></div> </li>
</ul>
</li>
</ul>
<p>Lets go through the individual functions and what you need to implement:</p>
<h4>create() Method </h4>
<p>This method needs to return a pointer to the base class. Internally the pointer should be a pointer to your manager class. So the implementation should look like this: </p>
<div class="fragment"><pre class="fragment">        <span class="keyword">static</span> Manager* create()
        {
            <span class="keywordflow">return</span> <span class="keyword">new</span> YOUR_MANAGER;
        }
</pre></div><h4>processRequest(Request&amp; req) Method </h4>
<p>Process a processing request. In the simple base class implementation the manager will call the <code>process</code> request method of all filters it depends on and will subsequently execute its own algorithm. If the request is delete it disconnects from all the algorithm it depends on.</p>
<h4>The Destructor </h4>
<p>If you have not allocated memory in your class an empty destructor is sufficient.</p>
<h4>The Constructor </h4>
<p>Make sure to call the <a class="el" href="classlibpipe_1_1rtc_1_1_manager.html">libpipe::rtc::Manager</a> Constructor. </p>
<div class="fragment"><pre class="fragment"> YOUR_MANAGER() :
                libpipe::rtc::Manager()
        { ...
</pre></div> <h4>registerLoader() Method </h4>
<p>This method will register your new manager class in the ManagerFactory. You can copy paste this method to your algorithm class, only change the identifier to you own individual one and call the create methode of your own class. </p>
<div class="fragment"><pre class="fragment"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> registerLoader()
{
    <a class="codeRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01203.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> ids = <span class="stringliteral">&quot;YOUR_MANAGER_IDENTIFIER&quot;</span>;
    <span class="keywordflow">return</span> <a class="code" href="classlibpipe_1_1utilities_1_1_singleton.html#ab7455b7e1235d292c444095842349291">libpipe::rtc::ManagerFactory::instance</a>().registerType(ids,YOUR_MANAGER::create);
}
</pre></div><p> To register your manager you need also to add this line of code outside your class: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">const</span> <span class="keywordtype">bool</span> YOUR_MANAGER::registered_ = registerLoader();
</pre></div><h3>Usage of Factories</h3>
<p>LIBPIPE supports factories for the generation of Algorithm and Managers Objects. The Factories are defined as <code>AlgorithmFactory</code> and <code>ManagerFactory</code> In order to support the generation of Filter at runtime LIBPIPE provides a factory-based (compile time) plugin system: every algorithm and manager class must provide a create method. The nifty thing about the LIBPIPE implementation of this setup is that adding a new class does not require editing any existing files. The whole procedure works the following way: </p>
<ul>
<li>If there is a new class that needs to be supported (e.g. <code>IdentityAlgorithm</code>), the user writes a class called <code>IdentityAlgorithm</code>, which is derived from <code><a class="el" href="classlibpipe_1_1rtc_1_1_algorithm.html">libpipe::rtc::Algorithm</a></code>. </li>
<li><code>IdentityAlgorithm</code> declares and defines its <code>create()</code> function, which constructs a <code>Algorithm</code>. </li>
<li>The startup code of <code>IdentityAlgorithm</code> would then register the new Algorithm with the <code>AlgorithmFactory</code>. Overall, the beginning of the implementation file would look like this: <div class="fragment"><pre class="fragment"> <span class="comment">// the virtual constructor (static function)</span>
 <span class="keyword">static</span> Algorithm* IdentityAlgorithm::create() {
    <span class="keywordflow">return</span> <span class="keyword">new</span> IdentityAlgorithm;
 }
 <span class="keyword">const</span> <span class="keywordtype">bool</span> IdentityAlgorithm::registerLoader()
 {
     <span class="keywordflow">return</span> AlgorithmFactory::instance().registerType(<span class="stringliteral">&quot;IdentityAlgorithm&quot;</span>,
         IdentityAlgorithm::create);
 }

 <span class="comment">// startup code to register the loader with the search result loader factory.</span>
 <span class="keyword">const</span> <span class="keywordtype">bool</span> IdentityAlgorithm::registered_ = registerLoader();
</pre></div></li>
</ul>
<p>In summary, every new Algorithm or Manager will notify the factory of its identifier and pass along a virtual constructor for the respective loader class.</p>
<h3><a class="anchor" id="datatypes"></a>Generate new Datatypes </h3>
<p>You can use the provided <a class="el" href="classlibpipe_1_1rtc_1_1_shared_data.html">libpipe::rtc::SharedData</a> template class to add your own datatypes. If you want to use <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html" title="STL class.">std::vector</a> to share data between filters you can do this the following way. </p>
<div class="fragment"><pre class="fragment"><a class="code" href="classlibpipe_1_1rtc_1_1_shared_data.html">libpipe::rtc::SharedData&lt;std::vector&lt;double&gt;</a> &gt;
</pre></div><p> If you use multithreading in your pipeline, the SharedData class also provides fast thread safe access. However you need to lock the class before you make use of any member functions. For multithreading sharedData provides the following functions: </p>
<div class="fragment"><pre class="fragment"><a class="codeRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01172.html#ga2bdabeb51d7e55d6358ad0857843ebea">libpipe::rtc::SharedData&lt;T&gt;::lock</a>()
libpipe::rtc::SharedData&lt;<a class="code" href="class_t.html">T</a>&gt;::shared_lock()
libpipe::rtc::SharedData&lt;<a class="code" href="class_t.html">T</a>&gt;::unlock()
</pre></div><p> Before calling any member functions you need to lock the class. With <code><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01172.html#ga2bdabeb51d7e55d6358ad0857843ebea">lock()</a></code> you get unique access to the class, you need this if you want to call <code>set</code>(...). With <code>shared_lock()</code> you get shared access to the class, this is needed if you want to call <code>get()</code> or <code>isNull()</code>. When you are finished with the access make sure to call <code>unlock()</code>. Otherwise you might get a dead lock.</p>
<p>If you want to create your own data type you need to inherit from <a class="el" href="classlibpipe_1_1rtc_1_1_data.html">libpipe::rtc::Data</a> . If you want to use your data type in multithreaded libpipe, you also need to implement your datatype thread safe.</p>
<h3>Implementation of own Input Files types</h3>
<p>With the libpipe library JSON input files are supported. You can define your own input files by implementing a own class which inherits from <a class="el" href="classlibpipe_1_1rtc_1_1_config.html">libpipe::rtc::Config</a>. For details see our implementation in <a class="el" href="classlibpipe_1_1rtc_1_1_config_j_s_o_n.html">libpipe::rtc::ConfigJSON</a>. To make use of your own class you need to change one line in <a class="el" href="classlibpipe_1_1rtc_1_1_pipeline_loader.html">libpipe::rtc::PipelineLoader</a>: </p>
<div class="fragment"><pre class="fragment">...
PipelineLoader::PipelineLoader(<span class="keyword">const</span> <a class="codeRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00552.html" title="STL class.">std::map&lt;std::string, std::string&gt;</a>&amp; inputFile)
{
    <span class="comment">//change this line with your own Implementation to support other input files.</span>
    configuration_ = <span class="keyword">new</span> ConfigJSON;
    ...
</pre></div><h3>JSON Input Files</h3>
<p>To configure libpipe with JSON files you need to generate three different files.</p>
<dl>
<dt>Filter  </dt>
<dd>defines your filters </dd>
<dt>Connection  </dt>
<dd>defines the connections between your filters </dd>
<dt>Pipeline  </dt>
<dd>defines execution of your pipeline </dd>
<dt>Parameters  </dt>
<dd>defines parameters for your filter objects </dd>
</dl>
<h4>Filter file</h4>
<p>In this file you need to define all filters. One Filter object will look like this: </p>
<div class="fragment"><pre class="fragment">{
    <span class="stringliteral">&quot;filters&quot;</span>: [
    ...
    ,{
            <span class="stringliteral">&quot;filterIdentifier&quot;</span>: <span class="stringliteral">&quot;IDENTIFIER_OF_FILTER&quot;</span>,
            <span class="stringliteral">&quot;algorithmName&quot;</span>: <span class="stringliteral">&quot;NAME_OF_ALGORITHM&quot;</span>,
            <span class="stringliteral">&quot;managerName&quot;</span>: <span class="stringliteral">&quot;NAME_OF_MANAGER&quot;</span>
    }...
    ]
}
</pre></div><p> <code>filterIdentifier</code> is your own chosen Identifier for the filter defined. <code>algorithmName</code> is the name of the algorithm class you want to use. <code>managerName</code> is the name of the manager class you want to use.</p>
<h4>Connections file</h4>
<p>In this file you define the connections between the individual filters.</p>
<div class="fragment"><pre class="fragment">{
    <span class="stringliteral">&quot;connections&quot;</span>: [
        ...
        ,{
            <span class="stringliteral">&quot;filterName&quot;</span>: <span class="stringliteral">&quot;IDENTIFIER_OF_FILTER&quot;</span>,
            <span class="stringliteral">&quot;identifier&quot;</span>: <span class="stringliteral">&quot;IDENTIFIER_OF_THIS&quot;</span>,
            <span class="stringliteral">&quot;precursors&quot;</span>: [
                {
                    <span class="stringliteral">&quot;precursorName&quot;</span>: <span class="stringliteral">&quot;IDENTIFIER_OF_PRECURSOR&quot;</span>
                }
            ],
            <span class="stringliteral">&quot;ports&quot;</span>: [
                {
                    <span class="stringliteral">&quot;filterName&quot;</span>: <span class="stringliteral">&quot;IDENTIFIER_OF_PRECURSOR&quot;</span>,
                    <span class="stringliteral">&quot;portNameOfFilter&quot;</span>: <span class="stringliteral">&quot;PORT_IDENTIFIER_OF_PRECURSOR&quot;</span>,
                    <span class="stringliteral">&quot;portNameOfThis&quot;</span>: <span class="stringliteral">&quot;PORT_IDENTIFIER_OF_THIS&quot;</span>
                }
            ]
        }
        ...
    ]
}
</pre></div><p> <code>filterName</code> is an identifier used to define a filter. <code>identifier</code> identifies this filter object. <code>precursorName</code> identifies the precursor filter object. <code>ports::filterName</code> identifies the precursor filter object. <code>portNameOfFilter</code> defines the port of this filter which will be connected to <code>portNameOfThis</code> port of the precursor filter object.</p>
<h4>Pipeline file</h4>
<p>Here the execution of your filters is defined. </p>
<div class="fragment"><pre class="fragment">{
    <span class="stringliteral">&quot;pipeline&quot;</span>: [
        ...
        ,{
            <span class="stringliteral">&quot;filterName&quot;</span>: <span class="stringliteral">&quot;IDENTIFIER_OF_FILTER&quot;</span>,
            <span class="stringliteral">&quot;requestType&quot;</span>: <span class="stringliteral">&quot;UPDATE&quot;</span>,
            <span class="stringliteral">&quot;requestRank&quot;</span>: 1,
            <span class="stringliteral">&quot;makeTrace&quot;</span>: <span class="stringliteral">&quot;true&quot;</span>
        }
        ...
    ]
}
</pre></div><p> <code>filterName</code> identifies the filter object where the in <code>requestType</code> defined request is executed. At the moment only the UPDATE and DELETE request can be executed. <code>requestRank</code> is an integer defining the order of execution the higher the later it will be executed. With the boolean <code>makeTrace</code> one can define if you want to generate a trace of the execution of this object.</p>
<h4>Parameters file</h4>
<p>In this file parameters for Filter Objects are defined. </p>
<div class="fragment"><pre class="fragment">{
    <span class="stringliteral">&quot;parameters&quot;</span>: [
        {
            <span class="stringliteral">&quot;filterIdentifier&quot;</span>: <span class="stringliteral">&quot;Source&quot;</span>,
            <span class="stringliteral">&quot;parameters&quot;</span>: [
                {
                    <span class="stringliteral">&quot;paramIdentifier&quot;</span>: <span class="stringliteral">&quot;SourceString&quot;</span>,
                    <span class="stringliteral">&quot;param&quot;</span>: <span class="stringliteral">&quot;Hello how are you World?&quot;</span>
                }
             ]
        },
        ...
    ]
}
</pre></div><p> <code>filterIdentifier</code> identifies the filter object where a new parameter <code>SourceString</code> with value </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>defined. To access a parameter from the object the following code can be used. Where the template parameter is the type of the parameter. </p>
<div class="fragment"><pre class="fragment">parameters_.get&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;ParameterName&quot;</span>);
</pre></div> </td></tr>
  </table>
  </dd>
</dl>
</div></div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Fri Mar 16 2012 08:21:46 for libpipe by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
